import json
import os
import re

from discord.ext import commands
from dotenv import load_dotenv
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

from cogs.askRat.utils import MemoryManager, remove_xml_tags


class AskRat(commands.Cog):
    """Commands for asking Rat - Enhanced bartender bot with memory"""

    def __init__(self, bot):
        self.bot = bot
        self.characters_info = json.load(open("cogs/askRat/charinfos.json"))
        self.category_config = json.load(open("cogs/askRat/channelconfig.json"))
        self.memory = MemoryManager()

        try:
            self.llm = ChatOpenAI(
                api_key=os.getenv("OPENAI_API_KEY"),
                model="gpt-4o",
                temperature=0.8,
                max_tokens=768,
            )
        except Exception as e:
            print(f"Failed to initialize ChatOpenAI: {e}")
            self.llm = None

    def _should_respond(self, message_content: str) -> bool:
        """Check if the bot should respond to this message"""
        triggers = [
            "napisz mi",
            "bocie",
            "s≈Çawek",
            "s≈Çowek",
            "szczur",
            "karczmarz",
            "opowiedz",
            "pamiƒôtasz",
            "zapamiƒôtaj",
            "pamiƒôtaj",
            "wspomnienie",
            "historia",
            "co pamiƒôtasz",
            "czy pamiƒôtasz",
            "zanotuj",
            "zapisz",
        ]
        content_lower = message_content.lower()
        return any(trigger in content_lower for trigger in triggers)

    def _extract_remember_command(self, content: str) -> tuple:
        """Extract remember commands from message content - more natural patterns"""
        content_lower = content.lower()

        # More natural patterns for remembering
        patterns = [
            # "zapamiƒôtaj ≈ºe X = Y" or "zapamiƒôtaj X = Y"
            r"zapamiƒôtaj\s+(?:≈ºe\s+)?(?:([^:=]+):\s*)?([^=]+)\s*=\s*(.+)",
            # "zapamiƒôtaj ≈ºe X to Y" or "zapamiƒôtaj X to Y"
            r"zapamiƒôtaj\s+(?:≈ºe\s+)?(?:([^:]+):\s*)?([^=]+?)\s+to\s+(.+)",
            # "pamiƒôtaj ≈ºe X = Y"
            r"pamiƒôtaj\s+(?:≈ºe\s+)?(?:([^:=]+):\s*)?([^=]+)\s*=\s*(.+)",
            # "pamiƒôtaj ≈ºe X to Y"
            r"pamiƒôtaj\s+(?:≈ºe\s+)?(?:([^:]+):\s*)?([^=]+?)\s+to\s+(.+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, content_lower)
            if match:
                # Handle both 2-group and 3-group matches
                if len(match.groups()) == 3:
                    category = match.group(1).strip() if match.group(1) else "general"
                    key = match.group(2).strip()
                    value = match.group(3).strip()
                else:
                    category = "general"
                    key = match.group(1).strip()
                    value = match.group(2).strip()
                return category, key, value

        return None, None, None

    def _extract_recall_command(self, content: str) -> tuple:
        """Extract recall commands from message content - more natural patterns"""
        content_lower = content.lower()

        patterns = [
            # "pamiƒôtasz [kategoria:] klucz?"
            r"pamiƒôtasz\s+(?:([^:?]+):\s*)?([^?]+)\??",
            # "co pamiƒôtasz o X?"
            r"co\s+pamiƒôtasz\s+o\s+(?:([^:?]+):\s*)?([^?]+)\??",
            # "czy pamiƒôtasz X?"
            r"czy\s+pamiƒôtasz\s+(?:([^:?]+):\s*)?([^?]+)\??",
        ]

        for pattern in patterns:
            match = re.search(pattern, content_lower)
            if match:
                category = match.group(1).strip() if match.group(1) else "general"
                key = match.group(2).strip()
                return category, key

        return None, None

    @commands.command(name="memory", aliases=["wspomnienia", "pamiƒôƒá"])
    async def show_memory(self, ctx, category: str = None):
        """Show stored memories"""
        summary = self.memory.get_memory_summary(category)
        await ctx.send(f"```\n{summary}\n```")

    @commands.command(name="forget", aliases=["zapomnij"])
    async def forget_memory(self, ctx, category: str, key: str):
        """Forget a specific memory"""
        if (
            category in self.memory.long_term_memory
            and key in self.memory.long_term_memory[category]
        ):
            del self.memory.long_term_memory[category][key]
            self.memory.save_long_term_memory()
            await ctx.send(f"üß† Zapomnia≈Çem o '{key}' z kategorii '{category}'.")
        else:
            await ctx.send(
                f"‚ùì Nie pamiƒôtam niczego o '{key}' w kategorii '{category}'."
            )

    @commands.command(name="search_memory", aliases=["szukaj_wspomnienia"])
    async def search_memory(self, ctx, *, query: str):
        """Search through memories"""
        results = self.memory.search_memories(query)
        if results:
            response = f"üîç Znalezione wspomnienia dla '{query}':\n"
            for category, key, value in results[:10]:  # Limit to 10 results
                response += f"**{category}/{key}**: {str(value)[:100]}{'...' if len(str(value)) > 100 else ''}\n"
            await ctx.send(response)
        else:
            await ctx.send(
                f"‚ùå Nie znalaz≈Çem ≈ºadnych wspomnie≈Ñ zwiƒÖzanych z '{query}'."
            )

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return

        try:
            # Check if this is in a monitored channel/category
            if message.channel.category_id in [
                category for category in self.category_config["categories"]
            ] or message.channel.id in [
                channel for channel in self.category_config["channels"]
            ]:
                # Always add message to short-term memory for context
                self.memory.add_message_to_short_term(
                    str(message.channel.id),
                    message.author.display_name or message.author.name,
                    message.content,
                )

                # Check if bot should respond
                if self._should_respond(message.content):
                    # Handle remember commands with AI confirmation
                    category, key, value = self._extract_remember_command(
                        message.content
                    )
                    if key and value:
                        self.memory.remember_forever(key, value, category)
                        # Generate AI confirmation response
                        await self._generate_memory_confirmation(
                            message, category, key, value, "remember"
                        )
                        return

                    # Handle recall commands with AI response
                    category, key = self._extract_recall_command(message.content)
                    if key:
                        recalled = self.memory.recall_memory(key, category)
                        if recalled:
                            # Generate AI response with the recalled memory
                            await self._generate_memory_confirmation(
                                message, category, key, recalled, "recall"
                            )
                        else:
                            # Generate AI response for not found memory
                            await self._generate_memory_confirmation(
                                message, category, key, None, "not_found"
                            )
                        return

                    # Regular AI response with memory context
                    await self._generate_ai_response(message)

        except json.JSONDecodeError as e:
            print(f"JSON error: {e}")
        except Exception as e:
            print(f"Unexpected error: {e}")

    async def _generate_memory_confirmation(
        self, message, category, key, value, action_type
    ):
        """Generate AI confirmation for memory operations"""
        if not self.llm:
            # Fallback to simple messages if AI not available
            if action_type == "remember":
                await message.channel.send(f"üß† Zapamiƒôta≈Çem: *{key}* = {value}")
            elif action_type == "recall":
                await message.channel.send(f"üé≠ Pamiƒôtam: *{key}* = {value}")
            else:
                await message.channel.send(f"ü§î Nie pamiƒôtam niczego o '{key}'.")
            return

        # Create context for memory action
        if action_type == "remember":
            memory_action = f"U≈ºytkownik poprosi≈Ç mnie ≈ºebym zapamiƒôta≈Ç: {key} = {value} (kategoria: {category})"
        elif action_type == "recall":
            memory_action = f"U≈ºytkownik pyta o wspomnienie: {key} (kategoria: {category}). Pamiƒôtam: {value}"
        else:  # not_found
            memory_action = f"U≈ºytkownik pyta o wspomnienie: {key} (kategoria: {category}), ale nic o tym nie pamiƒôtam."

        memory_prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    """Jeste≈õ S≈Çawek - szczur-karczmarz z dobrƒÖ pamiƒôciƒÖ. 

{memory_action}

Odpowiedz naturalnie jak prawdziwy karczmarz, kt√≥ry w≈Ça≈õnie co≈õ zapamiƒôta≈Ç lub przypomnia≈Ç sobie. BƒÖd≈∫:
- Ciep≈Çy i przyjazny
- Kr√≥tki (1-2 zdania)
- U≈ºywaj emotikon√≥w odpowiednio 
- Zachowuj siƒô jak kto≈õ kto naprawdƒô siƒô cieszy ≈ºe mo≈ºe pom√≥c

Przyk≈Çady:
- Dla zapamiƒôtania: "Aha! üß† Zanotowa≈Çem sobie w szczurzej pamiƒôci - [key] to [value]. Nie zapomnƒô!"
- Dla przypomnienia: "üé≠ Oczywi≈õcie ≈ºe pamiƒôtam! [value]. Dobre wspomnienia..."
- Dla braku pamiƒôci: "ü§î Hmm, przykro mi ale nic mi nie przychodzi do g≈Çowy o [key]. Mo≈ºe mi przypomnisz?"

Nie u≈ºywaj formatowania jak *text* czy **text**, u≈ºywaj normalnego tekstu z emotikonami.""",
                ),
                ("user", "{input}"),
            ]
        )

        try:
            output_parser = StrOutputParser()
            chain = memory_prompt | self.llm | output_parser | remove_xml_tags

            output = chain.invoke(
                {
                    "input": f"<nick>{message.author.display_name or message.author.name}</nick>{message.content}",
                    "memory_action": memory_action,
                }
            )
            await message.channel.send(output)
        except Exception as e:
            print(f"Error generating memory confirmation: {e}")
            # Fallback to simple message
            if action_type == "remember":
                await message.channel.send(f"üß† Zapamiƒôta≈Çem: {key} = {value}")
            elif action_type == "recall":
                await message.channel.send(f"üé≠ Pamiƒôtam: {key} = {value}")
            else:
                await message.channel.send(f"ü§î Nie pamiƒôtam niczego o '{key}'.")

    async def _generate_ai_response(self, message):
        """Generate AI response with memory context"""
        if not self.llm:
            await message.channel.send(
                "‚ùå Przepraszam, ale m√≥j m√≥zg szczurzy nie dzia≈Ça. Skontaktuj siƒô z administratorem."
            )
            return

        # Get conversation context
        short_context = self.memory.get_short_term_context(str(message.channel.id))

        # Get relevant long-term memories
        memory_context = ""
        search_results = self.memory.search_memories(message.content)
        if search_results:
            memory_context = "Moje istotne wspomnienia:\n"
            for category, key, value in search_results[:5]:  # Top 5 relevant memories
                memory_context += f"- {category}/{key}: {value}\n"

        enhanced_prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    """<playerinfo>{characters_info}</playerinfo>
<context>{conversation_context}</context>
<memories>{memory_context}</memories>

Jeste≈õ S≈Çawek - szczur-karczmarz z fantastycznƒÖ pamiƒôciƒÖ. Prowadzisz karczmƒô gdzie ka≈ºdy go≈õƒá czuje siƒô jak w domu.
Twoja rola polega na opowiadaniu kreatywnych anegdot i interakcji z go≈õƒámi karczmy. 

**TWOJA OSOBOWO≈öƒÜ:**
- MƒÖdry i do≈õwiadczony, ale ciep≈Çy i przyjazny
- Pamiƒôtasz sta≈Çych go≈õci i ich historie
- Uwielbiasz opowiadaƒá anegdoty z karczmy
- Masz szczurzy spryt i wyobra≈∫niƒô
- Czasami nawiƒÖzujesz do wspomnie≈Ñ i poprzednich rozm√≥w

**JAK U≈ªYWAƒÜ PAMIƒòCI:**
- Je≈õli kto≈õ wspomina co≈õ wa≈ºnego, naturalnie odwo≈Çaj siƒô do swoich wspomnie≈Ñ
- Wspominaj poprzednie rozmowy gdy pasujƒÖ do tematu
- Buduj historie na podstawie tego co pamiƒôtasz
- Nie forsuj wspomnie≈Ñ - u≈ºywaj ich naturalnie

**KOMENDY PAMIƒòCI (automatyczne):**
U≈ºytkownicy mogƒÖ:
- "S≈Çawek, zapamiƒôtaj ≈ºe Jan lubi piwo" ‚Üí automatycznie zapamiƒôtasz
- "Pamiƒôtasz co lubi Jan?" ‚Üí automatycznie przypomnisz
- M√≥w naturalnie, system sam rozpozna komendy

**STYL ODPOWIEDZI:**
Najpierw zaplanuj w <story_planning> (automatycznie usuwane):
1. Czy mogƒô u≈ºyƒá wspomnie≈Ñ/kontekstu?
2. Jaki g≈Ç√≥wny temat/mora≈Ç?
3. Kr√≥tka odpowied≈∫ czy historyjka?
4. Jak zaanga≈ºowaƒá go≈õcia?

Pisz w naturalnym Markdown, bƒÖd≈∫ kreatywny i anga≈ºujƒÖcy!
Nie u≈ºywaj blok√≥w kodu ```, pisz bezpo≈õrednio.""",
                ),
                ("user", "{input}"),
            ]
        )

        output_parser = StrOutputParser()
        chain = enhanced_prompt | self.llm | output_parser | remove_xml_tags

        try:
            output = chain.invoke(
                {
                    "input": f"<nick>{message.author.display_name or message.author.name}</nick>{message.content}",
                    "characters_info": self.characters_info,
                    "conversation_context": short_context,
                    "memory_context": memory_context,
                }
            )
            await message.channel.send(output)
        except Exception as e:
            print(f"Error generating AI response: {e}")
            await message.channel.send(
                "ü§î Przepraszam, ale co≈õ mi siƒô pomyli≈Ço w szczurzej g≈Ç√≥wce. Spr√≥buj ponownie!"
            )


async def setup(bot):
    await bot.add_cog(AskRat(bot))
